task clean {
	doLast {
		delete fileTree(rootDir) { include ':detect:vulnerabilities:*' }
	}
}

for (rootFile in rootDir.listFiles()) {
	if (rootFile.name.startsWith(':detect:targets') && !rootFile.name.endsWith('.raw')) {
		def service = rootFile.name - ':detect:targets:'

		if (file(service).exists()) {
			task "$service" {
				group = "group"
				dependsOn tasks.matching { it.name.endsWith(":$service") && it.name != name }
			}

			def serviceHosts = rootFile.readLines()

			for (serviceHost in serviceHosts) {
				task "$serviceHost:$service" {
					ext.outputFilePath = "$rootDir/${it.path}"
					ext.host = serviceHost
					ext.issues = []
					ext.scriptDir = file(service)
					doLast {
						for (scriptFile in scriptDir.listFiles()) {
							if (scriptFile.name.endsWith('.py')) {
								String issue = scriptFile.name - '.py'

								def byteArrayOutputStream = new ByteArrayOutputStream()

								exec {
									executable 'python'
									args = ["$scriptFile", "http://$host"]
									workingDir = scriptDir
									standardOutput = byteArrayOutputStream
									errorOutput = new ByteArrayOutputStream()
									ignoreExitValue = true
								}

								if (byteArrayOutputStream.toString().trim() == 'vulnerable') {
									issues.add(issue)
								}
							}
							else if (scriptFile.name.endsWith('.sh')) {
								String issue = scriptFile.name - '.sh'

								def byteArrayOutputStream = new ByteArrayOutputStream()

								exec {
									executable 'sh'
									args = ["$scriptFile", host]
									standardOutput = byteArrayOutputStream
									errorOutput = new ByteArrayOutputStream()
								}

								if (byteArrayOutputStream.toString().trim() == 'vulnerable') {
									issues.add(issue)
								}
							}
						}
					}

					doLast {
						if (!issues.isEmpty()) {
							file(outputFilePath).append("${issues.join(',')}\n")
						}
					}
				}

				task "$serviceHost" {
					ext.host = serviceHost
					dependsOn tasks.matching { it.name.startsWith(host) && it.name != name }
				}
			}
		}
	}
}

tasks.addRule("Pattern: [A-Z]+-\\d+") { String taskName ->
	if (taskName.matches("[A-Z]+-\\d+")) {
		task(taskName) {
			dependsOn tasks.matching { it.name.matches(".*[A-Z]+-\\d+.*") && it.name != taskName }
		}
	}
}