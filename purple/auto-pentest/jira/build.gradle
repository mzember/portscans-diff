import java.text.SimpleDateFormat
import pl.allegro.finance.tradukisto.ValueConverters

Properties properties = new Properties()

File propertiesFile = new File("$rootDir/jira/gradle-ext.properties")

propertiesFile.withInputStream {
	properties.load(it)
}

for (property in properties) {
	project.ext."${property.key}" = "${property.value}"
}

buildscript {
	repositories {
		mavenCentral()
	}

	dependencies {
		classpath 'pl.allegro.finance:tradukisto:0.5.1'
	}
}

tasks.withType(Exec) {
	args '--silent', '--user', "$username:$password", '-H', "Content-Type: application/json"

	ext.standardOutputJson = null

	def outputStream = new ByteArrayOutputStream()

	standardOutput = outputStream

	doLast {
		standardOutputJson = new groovy.json.JsonSlurper().parseText(outputStream.toString())
	}
}

task createIssues {
	doLast {
		Date scanDate = new Date()

		String scanID = new SimpleDateFormat("yyyyMMddHHmmss").format(scanDate)

		def remoteIssueVulnerabilityLabels = []

		def getIssuesOutputStream = new ByteArrayOutputStream()

		def queryPath = "https://$jiraHost/rest/api/2/search"
		def queryParams = """jql=cf\\[$scriptLabelsCustomFieldId\\]%20in%20("scan:owner-host-vulnerabilities","type:generated")%20and%20status%20not%20in%20(closed)"""

		def queryURL = "$queryPath?$queryParams"

		exec {
			executable 'curl'
			args '--silent', '--user', "$username:$password", '-H', "Content-Type: application/json"
			args "$queryURL"
			standardOutput = getIssuesOutputStream
		}

		def remoteIssuesJson = new groovy.json.JsonSlurper().parseText(getIssuesOutputStream.toString()).issues

		for (remoteIssueJson in remoteIssuesJson) {
			def remoteIssueLabels = remoteIssueJson.fields."customfield_$scriptLabelsCustomFieldId"

			for (remoteIssueLabel in remoteIssueLabels) {
				if (!remoteIssueLabel.startsWith("$hostVulnerabilityLabelPrefix")) {
					continue
				}

				remoteIssueVulnerabilityLabels.add(remoteIssueLabel.toString())
			}
		}

		def createdIssuesCount = 0

		def skippedHostVulnerabilities = 0

		def newHostVulnerabilities = 0

		def localIssuesJson = new groovy.json.JsonSlurper().parseText(file("../detect/issues.json").text)

		for (localIssueJson in localIssuesJson) {
			def labels = localIssueJson.labels

			if (labels == 'null') {
				continue
			}

			def localIssueLabels = labels*.toString()

			if (localIssueLabels == null) {
				continue
			}

			def newLocalIssuesLabels = localIssueLabels

			def alreadyCreatedHostVulnerabilityLabels = remoteIssueVulnerabilityLabels

			def newLocalIssuesLabelsSize = newLocalIssuesLabels.size()

			newLocalIssuesLabels.removeAll(alreadyCreatedHostVulnerabilityLabels)

			def newLocalIssuesLabelsSize2 = newLocalIssuesLabels.size()

			def skippedHostVulnerabilityLabelsSize = newLocalIssuesLabelsSize - newLocalIssuesLabelsSize2

			skippedHostVulnerabilities += skippedHostVulnerabilityLabelsSize

			newHostVulnerabilities += newLocalIssuesLabelsSize2

			if (newLocalIssuesLabels.size() < 1) {
				continue
			}

			def newIssueLabels = []

			newIssueLabels.add("type:generated")
			newIssueLabels.add("scanID:$scanID".toString())
			newIssueLabels.add("tool:$toolName")
			newIssueLabels.add("tool-version:$toolName-$toolVersion")

			def hosts = []
			def vulnerabilities = []

			for (newLocalIssueLabel in newLocalIssuesLabels) {
				newIssueLabels.add("$newLocalIssueLabel".toString())

				def host = "${newLocalIssueLabel.replace("$hostVulnerabilityLabelPrefix", "").split(";")[0]}".toString()

				newIssueLabels.add("host:$host".toString())

				hosts.add(host)

				def vulnerability = "${newLocalIssueLabel.replace("$hostVulnerabilityLabelPrefix", "").split(";")[1]}".toString()

				newIssueLabels.add("vulnerability:$vulnerability".toString())

				vulnerabilities.add(vulnerability)
			}

			def hostVulnerabilities = [:]

			hosts = hosts.toUnique().toSorted()

			for (host in hosts) {
				for (newLocalIssueLabel in newLocalIssuesLabels) {
					if (newLocalIssueLabel.contains("$host".toString())) {
						def vulnerability = "${newLocalIssueLabel.replace("$hostVulnerabilityLabelPrefix", "").split(";")[1]}".toString()

						if (hostVulnerabilities.containsKey(host.toString())) {
							def hostVulns = hostVulnerabilities.get(host.toString())

							hostVulns.add(vulnerability)
							hostVulns.sort()
						}
						else {
							hostVulnerabilities.put(host, [vulnerability])
						}
					}
				}
			}

			def description = "$descriptionPrefix"

			description += "||host||"

			def uniqueSortedVulnerabilities = vulnerabilities.sort().toUnique()

			for (vulnerability in uniqueSortedVulnerabilities) {
				description += "$vulnerability||"
			}

			description += "\\n"

			def uniqueSortedHosts = (hostVulnerabilities.keySet() as List).sort()

			for (host in uniqueSortedHosts) {
				description += "|[http://$host]|"

				def theHostVulnerabilities = hostVulnerabilities.get(host)

				for (uniqueSortedVulnerability in uniqueSortedVulnerabilities) {
					if (theHostVulnerabilities.contains(uniqueSortedVulnerability)) {
						description += "* |"
					}
					else {
						description += " |"
					}
				}

				description += "\\n"
			}

			Calendar calendar = Calendar.getInstance()

			calendar.setTime(scanDate)

			calendar.add(Calendar.DAY_OF_YEAR, Integer.parseInt(recycleCandidateTimeout))

			Date twoWeeksTime = calendar.getTime()

			String recycleCandidateDate = new SimpleDateFormat("EEEE, MMMM dd, yyyy").format(twoWeeksTime)

			description += "If you don't respond to us on this ticket in two weeks (by $recycleCandidateDate), the above VM resources will become candidates for IT recycling.\\n"

			def vulnerabilitySize = uniqueSortedVulnerabilities.size()

			def vulnerabilityWords = "vulnerability was"

			if (vulnerabilitySize > 1) {
				vulnerabilityWords = "vulnerabilities were"
			}

			String vulnerabilitySizeWords = ValueConverters.ENGLISH_INTEGER.asWords(vulnerabilitySize)

			def hostSize = hosts.size()

			def hostWord = "host"

			if (hostSize > 1) {
				hostWord = "hosts"
			}

			String hostSizeWords = ValueConverters.ENGLISH_INTEGER.asWords(hostSize)

			def ownerName = "no one"

			def assignee = localIssueJson.assignee.toString()

			if (assignee != "") {
				ownerName = (localIssueJson.assignee).toString().split("\\.")*.capitalize().join(" ")
			}

			def summary = "${vulnerabilitySizeWords.capitalize()} $vulnerabilityWords found on $hostSizeWords $hostWord owned by $ownerName".toString()

			def createIssueOutputStream = new ByteArrayOutputStream()

			exec {
				executable 'curl'
				args '--silent', '--user', "$username:$password", '-H', "Content-Type: application/json"
				args '--data', $/{"fields":{"project":{"key":"LRINFOSEC"},"components":[{"name":"Blue Team"}],"assignee":{"name": "${localIssueJson.assignee}"},"summary":"${summary}","description":"${description}","issuetype":{"name":"$createIssueType"},"customfield_$scriptLabelsCustomFieldId":["${newIssueLabels.join('","')}"]}}/$
				args "https://$jiraHost/rest/api/2/issue"
				standardOutput = createIssueOutputStream
				errorOutput = createIssueOutputStream
			}

			def remoteIssueKey = new groovy.json.JsonSlurper().parseText(createIssueOutputStream.toString()).key

			def issueURL = "http://$jiraHost/browse/$remoteIssueKey".toString()

			def outputMessage = $/Created issue with summary "$remoteIssueKey $summary" for $ownerName at $issueURL/$.toString()

			println outputMessage

			createdIssuesCount += 1
		}

		if (createdIssuesCount == 0) {
			println "All vulnerabilities found already have tickets."
		}

		println "The number of host vulnerabilities with tickets already created: $skippedHostVulnerabilities"
		println "The number of new host vulnerabilities: $newHostVulnerabilities"
		println "The number of new tickets created for new host vulnerabilities: $createdIssuesCount"
		println "To view all new tickets go to: https://issues-uat.liferay.com/issues/?jql=cf%5B$scriptLabelsCustomFieldId%5D%20%3D%20scanID%3A$scanID"
	}
}